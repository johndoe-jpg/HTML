package checkers;

import java.awt.Color;
import java.awt.Graphics;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

/**
 *
 * @author THUND
 */
public class Board extends javax.swing.JPanel implements PropertyChangeListener {

    private Piece[][] board;
    private int tiles = 8;
    private boolean whiteTurn = true;
    private boolean gameOver = false;

    /**
     * Creates new Board
     */
    public Board() {
        initComponents();
        setUpGame();
    }

    /*
        TO SIMPLYFI, WHITE WILL ALWAYS START AT THE BOTTOM
     */
    private void setUpGame() {
        board = new Piece[tiles][tiles];

        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[i].length; j++) {
                if (j < 3 && (j + 1 + (i % 2)) % 2 == 0) {
                    board[i][j] = new Piece(false);
                }
                if (j > 4 && (j + 1 + (i % 2)) % 2 == 0) {
                    board[i][j] = new Piece(true);
                }
            }
        }
        gameOver = false;
        repaint();
    }
    
    private boolean isEmptyTile(int x, int y) {
        try {
            return (board[x][y] == null);
        } catch (IndexOutOfBoundsException ignored) {
        }
        return false;
    }

    private boolean isOccupiedTile(int x, int y) {
        try {
            return (board[x][y] != null);
        } catch (IndexOutOfBoundsException ignored) {
        }
        return false;
    }

    private void clearSelection() {
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[i].length; j++) {
                if (board[i][j] != null) {
                    board[i][j].setSelected(false);
                }
            }
        }
    }

    private boolean pieceHasAvalibleMoves(int x, int y) {
        boolean hasMoves = false;

        try {
            if (board[x][y] == null) {
                return hasMoves;
            }
        } catch (Exception e) {
        }

        int aX, aY; // active x, y
        aX = aY = -1;

        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[i].length; j++) {
                if (board[i][j] != null && board[i][j].isSelected()) {
                    aX = i;
                    aY = j;
                    board[i][j].setSelected(false);
                    break;
                }
            }
        }

        board[x][y].setSelected(true);

        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[i].length; j++) {
                if (isValidMove(i, j, true)) {
                    hasMoves = true;
                    break;
                }
            }
        }

        board[x][y].setSelected(false);
        if (aX != -1) {
            board[aX][aY].setSelected(true);
        }

        return hasMoves;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                formMouseReleased(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 600, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 600, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    private void formMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseReleased
        int[] tile = getTileFromCoords(evt.getX(), evt.getY());
        if (isOutOfBound(tile[0], tile[1]) || gameOver) {
            return;
        }
        Piece selectedTile = board[tile[0]][tile[1]];
        if (selectedTile != null && selectedTile.isWhite() == whiteTurn) {
            clearSelection();
            selectedTile.setSelected(true);
            repaint();
        } else {
            if (isValidMove(tile[0], tile[1], false)) {
                // Move Piece
                int[] active = getSelectedTile();
                if (active != null) {
                    movePiece(active[0], active[1], tile[0], tile[1]);
                    clearSelection();
                    whiteTurn = !whiteTurn;
                    repaint();
                }
                // Check if the other side has availible moves
                boolean noMoves = true;
                for (int i = 0; i < board.length; i++) {
                    for (int j = 0; j < board[i].length; j++) {
                        if (board[i][j] != null && board[i][j].isWhite() == whiteTurn) {
                            if (pieceHasAvalibleMoves(i, j)) {
                                noMoves = false;
                            }
                        }
                    }
                }
                if (noMoves) {
                    gameOver();
                    return;
                }
                // Game ins't over, check upgrade
                for (int i = 0; i < board.length; i++) {
                    checkUpgrade(i, 0, true);
                    checkUpgrade(i, board[i].length - 1, false);
                }
            }
        }
    }//GEN-LAST:event_formMouseReleased

    private boolean isOutOfBound(int x, int y) {
        return (x < 0 || y < 0 || x >= board.length || y >= board[0].length);
    }

    private void checkUpgrade(int i, int j, boolean color) {
        if (board[i][j] != null && board[i][j].isWhite() == color) {
            board[i][j].upgradeToQueen();
        }
    }

    private int[] getTileFromCoords(int x, int y) {
        int tileSize = getHeight()/ tiles;

        return new int[]{x / tileSize, y / tileSize};
    }

    /**
     * There is no protection against having multiple selected tiles, but this
     * func. returns only the first one
     *
     * @return
     */
    private int[] getSelectedTile() {
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[i].length; j++) {
                if (board[i][j] != null && board[i][j].isSelected()) {
                    return new int[]{i, j};
                }
            }
        }
        return null;
    }

    /**
     *
     * @param sx - Start x
     * @param sy - Start y
     * @param dx - Destination x
     * @param dy - Destination y
     */
    private void movePiece(int sx, int sy, int dx, int dy) {
        if (board[dx][dy] != null) {
            return;
        }
        board[dx][dy] = board[sx][sy];
        board[sx][sy] = null;
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        int s = getHeight(); // Size of the window, too lazy to type getWidth()
        int tileSize = s / tiles;

        // Draw board
        g.setColor(Color.lightGray);
        g.fillRect(0, 0, s, s);

        g.setColor(Color.darkGray);
        int letter = 0x0041;
        for (int i = 0; i < tiles; i++) {
            for (int j = 0; j < tiles; j++) {
                if (i % 2 == 0) { // ROWS
                    // even
                    if (j % 2 == 1) {
                        g.fillRect(i * tileSize, j * tileSize, tileSize, tileSize);
                    }
                } else {
                    // odd
                    if (j % 2 == 0) {
                        g.fillRect(i * tileSize, j * tileSize, tileSize, tileSize);
                    }
                }
            }
        }

        // Draw pieces
        for (int i = 0; i < tiles; i++) {
            for (int j = 0; j < tiles; j++) {
                // Skip if no piece
                if (board[i][j] == null) {
                    continue;
                }

                // Show selecable
                if (board[i][j].isWhite() == whiteTurn) {
                    if (pieceHasAvalibleMoves(i, j)) {
                        g.setColor(Color.orange);
                        g.fillRect(i * tileSize, j * tileSize, tileSize, tileSize);
                    }
                }

                // Show selected + moves
                if (board[i][j].isSelected()) {
                    g.setColor(Color.green);
                    g.fillRect(i * tileSize, j * tileSize, tileSize, tileSize);
                    drawMoves(i, j, g, tileSize);
                }

                // Show pieces
                g.setColor((board[i][j].isWhite()) ? Color.white : Color.black);
                g.fillOval(i * tileSize, j * tileSize, tileSize, tileSize);
                if (board[i][j].isQueen()) {
                    g.setColor((!board[i][j].isWhite()) ? Color.white : Color.black);
                    g.fillOval((i * tileSize) + tileSize / 4, (j * tileSize) + tileSize / 4, tileSize / 2, tileSize / 2);
                }
            }
        }
    }

    private void drawMoves(int x, int y, Graphics g, int tileSize) {
        if (!board[x][y].isQueen()) {
            // Normal piece
            if (board[x][y].isWhite()) {
                checkAndDrawMoves(x - 1, y - 1, g, tileSize, x, y);
                checkAndDrawMoves(x + 1, y - 1, g, tileSize, x, y);
            } else {
                checkAndDrawMoves(x - 1, y + 1, g, tileSize, x, y);
                checkAndDrawMoves(x + 1, y + 1, g, tileSize, x, y);
            }
        } else {
            // Queen
            int l_r = -1;
            int t_b = -1;
            for (int k = 0; k < 4; k++) {
                // Loop board.length times to get all the possible moves from corner to corner
                for (int l = 0; l < board.length; l++) {
                    try {
                        int nx = x + (l_r * l);
                        int ny = y + (t_b * l);
                        if(isValidMove(nx, ny, true)) {
                            checkAndDrawMoves(nx, ny, g, tileSize, x, y);
                        }
                    } catch (IndexOutOfBoundsException e) {
                        // We left the playable area, don't need to check further
                        break;
                    }
                }

                if (k % 2 == 1) {
                    l_r = -1;
                } else {
                    l_r = 1;
                }
                if (k >= 1) {
                    t_b = 1;
                }
            }
        }
    }

    private void checkAndDrawMoves(int x, int y, Graphics g, int tileSize, int ogX, int ogY) {
        if (isEmptyTile(x, y)) {
            g.setColor(Color.green);
            g.fillRect((x) * tileSize, (y) * tileSize, tileSize, tileSize);
        }
        if (isOccupiedTile(x, y) && board[x][y].isWhite() != board[ogX][ogY].isWhite()) {
            // Enemy next to us
            // Check if the tile after it, in the direction from the original piece, is empty
            // Get X & Y of destination
            int dX = x - (ogX - x);
            int dY = y - (ogY - y);
            try {
                if (board[dX][dY] == null) {
                    g.setColor(Color.green);
                    g.fillRect((dX) * tileSize, (dY) * tileSize, tileSize, tileSize);
                }
            } catch (Exception e) {
            }
        }
    }

    /**
     * Checks wether a move is valid for ALL SELECTED PIECES
     *
     * @param x
     * @param y
     * @param readOnly
     */
    private boolean isValidMove(int x, int y, boolean readOnly) {
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[i].length; j++) {
                if (board[i][j] != null && board[i][j].isSelected()) {
                    // Found a selected piece
                    // Is it a normal piece?
                    if (!board[i][j].isQueen()) {
                        // Check its avalible moves
                        int orientation = -1;
                        if (board[i][j].isWhite()) {
                            orientation = 1;
                        }

                        if (checkValid(i - 1, j - 1 * orientation, x, y) || checkValid(i + 1, j - 1 * orientation, x, y)) {
                            return true;
                        }

                        int side = 0;
                        if (checkEnemy(i - 1, j - 1 * orientation, i, j)) {
                            if (checkValid(i - 2, j - 2 * orientation, x, y)) {
                                side = 1;
                            }
                        }
                        if (checkEnemy(i + 1, j - 1 * orientation, i, j)) {
                            if (checkValid(i + 2, j - 2 * orientation, x, y)) {
                                side = -1;
                            }
                        }
                        if (side != 0) {
                            if (!readOnly) {
                                board[i - 1 * side][j - 1 * orientation] = null;
                            }
                            return true;
                        }
                    } else {
                        // Queen has different movement, but luckily it's the same for both colors
                        // Quite an inefficient way to do it, but a guaranteed way to get all the moves
                        // Loop 4 times for all the directions
                        int l_r = -1;
                        int t_b = -1;
                        for (int k = 0; k < 4; k++) {
                            int enemyX = -1;
                            int enemyY = -1;
                            // Loop board.length times to get all the possible moves from corner to corner
                            for (int l = 1; l < board.length; l++) {
                                try {
                                    int nx = i + (l_r * l);
                                    int ny = j + (t_b * l);
                                    Piece cur = board[nx][ny];

                                    // System.out.println("Is " + x + ", " + y + " at " + nx + ", " + ny);
                                    if (isOccupiedTile(nx, ny)) {
                                        if (board[nx][ny].isWhite() != board[i][j].isWhite()) {
                                            // Pass an enemy
                                                if (enemyX != -1) {
                                                    // Passing multiple enemies, can't do that
                                                    break;
                                                } else {
                                                    enemyX = nx;
                                                    enemyY = ny;
                                                }
                                        } else {
                                            // Pass a friend
                                            break;
                                        }
                                    }
                                    if (nx == x && ny == y) {
                                        if (cur == null) {
                                            // The move was valid
                                            // If we passed an enemy, delete it
                                            if (!readOnly && enemyX != -1) {
                                                board[enemyX][enemyY] = null;
                                            }
                                            return true;
                                        } else {
                                            return false;
                                        }
                                    }
                                } catch (IndexOutOfBoundsException e) {
                                    // We left the playable area, don't need to check further
                                    break;
                                }
                            }

                            if (k % 2 == 1) {
                                l_r = -1;
                            } else {
                                l_r = 1;
                            }
                            if (k >= 1) {
                                t_b = 1;
                            }
                        }
                    }
                }
            }
        }

        return false;
    }

    private boolean checkValid(int cx, int cy, int x, int y) {
        return ((cx == x && cy == y) && isEmptyTile(cx, cy));
    }

    private boolean checkEnemy(int cx, int cy, int i, int j) {
        return (isOccupiedTile(cx, cy) && (board[i][j].isWhite() != board[cx][cy].isWhite()));
    }

    private void gameOver() {
        // Game over
        gameOver = true;
        firePropertyChange("gameOver", null, whiteTurn);
    }

    @Override
    public void propertyChange(PropertyChangeEvent pce) {
       if(pce.getPropertyName().equals("reset")) {
           setUpGame();
       }
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
